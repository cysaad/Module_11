# -*- coding: utf-8 -*-
"""Module_11

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17vgCPI3pB4PGRmSS55OpDSQFF3JnatIg
"""

# Import required libraries and dependencies
import pandas as pd
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler

# Load the data into a Pandas DataFrame and make the index the "coin_id" column.
market_data_df = pd.read_csv("crypto_market_data.csv", index_col="coin_id")

# Display sample data
market_data_df.head(10)

# Generate summary statistics
market_data_df.describe()

"""### Prepare the Data"""

# Use the `StandardScaler()` module from scikit-learn to normalize the data from the CSV file
scaler = StandardScaler()

# Create a DataFrame with the scaled data
scaled_data= scaler.fit_transform(market_data_df)
scaled_data_df = pd.DataFrame(scaled_data, columns=market_data_df.columns)
# Copy the crypto names from the original data
crypto_names = market_data_df.index.copy()

# Set the coinid column as index
scaled_data_df = scaled_data_df.reset_index(drop=True)
scaled_data_df.index = crypto_names



# Display sample data
print(scaled_data_df.head(10))

"""### Find the Best Value for k Using the Original Scaled DataFrame."""

# Create a list with the number of k-values to try
# Use a range from 1 to 11
k_values = list(range(1, 12))

# Create an empty list to store the inertia values
inertia = []





# Create a for loop to compute the inertia with each possible value of k
# Inside the loop:
# 1. Create a KMeans model using the loop counter for the n_clusters
# 2. Fit the model to the data using the scaled DataFrame
# 3. Append the model.inertia_ to the inertia list


for k in k_values:
    model = KMeans(n_clusters=k)
    model.fit(scaled_data_df)
    inertia.append(model.inertia_)


# Create a dictionary with the data to plot the Elbow curve
elbow_data = {
    'k': k_values,
    'inertia': inertia
}




# Create a DataFrame with the data to plot the Elbow curve
elbow_df = pd.DataFrame(elbow_data)

# Display the DataFrame
print(elbow_df)

# Plot a line chart with all the inertia values computed with
# the different values of k to visually identify the optimal value for k.
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
plt.plot(elbow_df['k'], elbow_df['inertia'], marker='o')
plt.title('Elbow Method For Optimal k')
plt.xlabel('Number of clusters, k')
plt.ylabel('Inertia')
plt.xticks(k_values)
plt.show()

"""#### Answer the following question:
**Question:** What is the best value for `k`?

**Answer:** 5 and 6

### Cluster Cryptocurrencies with K-means Using the Original Scaled Data.
"""

# Initialize the K-Means model using the best value for k
kmeans_model = KMeans(n_clusters=5)

# Fit the K-Means model using the scaled data
kmeans_model.fit(scaled_data_df)

# Predict the clusters to group the cryptocurrencies using the scaled data
cluster_labels = kmeans_model.fit_predict(scaled_data_df)


# View the resulting array of cluster values.

print(cluster_labels)

# Create a copy of the DataFrame
# Assuming scaled_data_df is your original DataFrame
scaled_data_df = scaled_data_df.copy()

# Add a new column to the DataFrame with the predicted clusters
scaled_data_df['Cluster'] = cluster_labels

# Display sample data
# Display the first 5 rows of the DataFrame
print(scaled_data_df.head())

# Create a scatter plot using Pandas plot by setting
# `x="price_change_percentage_24h"` and `y="price_change_percentage_7d"`.
# Use "rainbow" for the color to better visualize the data.
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
plt.scatter(scaled_data_df['price_change_percentage_24h'], scaled_data_df['price_change_percentage_7d'], c=scaled_data_df['Cluster'], cmap='winter')
plt.xlabel('Price Change Percentage 24h')
plt.ylabel('Price Change Percentage 7d')
plt.title('Scatter Plot of Price Changes')
plt.colorbar(label='Cluster')
plt.show()

"""### Optimize Clusters with Principal Component Analysis."""

# Create a PCA model instance and set `n_components=3`.

pca_model = PCA(n_components=3)

# Use the PCA model with `fit_transform` on the original scaled DataFrame to reduce to three principal components.

pca_result = pca_model.fit_transform(scaled_data_df)

# Convert the PCA result into a DataFrame for easier analysis
pca_df = pd.DataFrame(data=pca_result, columns=['Principal Component 1', 'Principal Component 2', 'Principal Component 3'])


pca_df.index = scaled_data_df.index

# Display the first few rows of the PCA result
print(pca_df.head())

# Retrieve the explained variance to determine how much information  can be attributed to each principal component.
explained_variance_ratio = pca_model.explained_variance_ratio_
explained_variance_ratio

"""#### Answer the following question:

**Question:** What is the total explained variance of the three principal components?

**Answer:** 37.20%+34.70%+17.60%=89.50%
"""

# Create a new DataFrame with the PCA data.
# Note: The code for this step is provided for you
pca_df = pd.DataFrame(data=pca_result, columns=['Principal Component 1', 'Principal Component 2', 'Principal Component 3'])
# Creating a DataFrame with the PCA data


# Copy the crypto names from the original data

pca_df['coinid'] = scaled_data_df.index

#  set 'coinid' as the index of pca_df

pca_df = pca_df.set_index('coinid')

# Display sample data
print(pca_df.head())

"""### Find the Best Value for k Using the PCA Data"""

# Create a list with the number of k-values to try
# Use a range from 1 to 11

k_values = range(2, 11)  # For example, testing k from 2 to 10

# Step 2: Calculate Inertia for Each k

# Create an empty list to store the inertia values
inertia = []

# Create a for loop to compute the inertia with each possible value of k
# Inside the loop:
# 1. Create a KMeans model using the loop counter for the n_clusters
# 2. Fit the model to the data using PCA DataFrame.
# 3. Append the model.inertia_ to the inertia list
for k in k_values:
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(pca_df)
    inertia.append(kmeans.inertia_)

# Create a dictionary with the data to plot the Elbow curve
import pandas as pd

elbow_data = {
    'Number of Clusters': k_values,
    'Inertia': inertia
}

# Create a DataFrame
elbow_df = pd.DataFrame(elbow_data)

# Step 3: Display the DataFrame
print(elbow_df)

# Plot a line chart with all the inertia values computed with
# the different values of k to visually identify the optimal value for k.
plt.figure(figsize=(8, 4))
plt.plot(k_values, inertia, marker='o')
plt.title('Elbow Method For Optimal k')
plt.xlabel('Number of clusters (k)')
plt.ylabel('Inertia')
plt.xticks(k_values)
plt.show()

"""#### Answer the following questions:
* **Question:** What is the best value for `k` when using the PCA data?

  * **Answer:** 4


* **Question:** Does it differ from the best k value found using the original data?

  * **Answer:** intertia decreased rapidely after 5 and 6 in original data

### Cluster Cryptocurrencies with K-means Using the PCA Data
"""

# Initialize the K-Means model using the best value for k
# Initialize the K-Means model using the best value for k
model = KMeans(n_clusters=4)

# Fit the K-Means model using the PCA data
model.fit(pca_df)

# Predict the clusters to group the cryptocurrencies using the PCA data

y_kmeans = model.predict(pca_df)

# Print the resulting array of cluster values.
# Print the resulting array of cluster values.
print(y_kmeans)

# Create a copy of the DataFrame with the PCA data
pca_df = pca_df.copy()

# Add a new column to the DataFrame with the predicted clusters
pca_df['Cluster'] = y_kmeans

# Display sample data
print(pca_df.head())

pip install hvplot

# Create a scatter plot using hvPlot by setting `x="PCA1"` and `y="PCA2"`.
import hvplot.pandas  #

# Create a scatter plot
scatter_plot = pca_df.hvplot.scatter(x='Principal Component 1', y='Principal Component 2', by='Cluster', title="PCA Scatter Plot")

# Display the plot
scatter_plot

#  Use the columns from the original scaled DataFrame as the index.
labels = pd.DataFrame(pca_model.components_, columns=scaled_data_df.columns, index=[f'Principal Component {i+1}' for i in range(pca_model.n_components_)])

# Display the loadings
print(labels)

"""### Determine the Weights of Each Feature on each Principal Component

#### Answer the following question:

* **Question:** Which features have the strongest positive or negative influence on each component?

* **Answer:** Strongest positive influence on each component: (1) 7-day price change, (2) 200-day price change, (3) 30-day price change.
Strongest negative influence on each component: (1) None, (2) 24-hour price change, (3) Cluster.
"""

